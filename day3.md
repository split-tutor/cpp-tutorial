SPLIT 코딩 학습과정 DAY 3
===

#### Last edit 14/10/2018
#### Contact: Seonghyun Park <<split.tutor@gmail.com>>

## 1. 학습목표

함수를 선언하는 방법과 호출하는 방법에 대해서 배운다.

Call-by-value와 Call-by-reference의 차이점에 대해 배운다.

Recursive하게 호출되는 함수의 동작 방식을 이해한다.

Array, struct, union 등 다양한 타입에 대해 배우고 적절하게 사용할 수 있다.

## 2. 함수
지금까지 우리가 작성한 프로그램은 모두 `int main()`에 선언된 문장만을 차례대로 실행했습니다.
뭔가 불편한 점이 없으셨나요?
예컨대 `std::string` 내부에서 알파벳 `c`와 `e`의 개수를 세는 프로그램을 생각해봅시다.

```cpp
std::string s = "practice makes perfect";

int num_of_c = 0, num_of_e = 0;

for (char c : s) {
    if (c == 'c')
        num_of_c += 1;
}

for (char c : s) {
    if (c == 'e')
        num_of_e += 1;
}

// num_of_c:  3, num_of_e: 4
```

'c' 대신'e'가 쓰였다는 것 정도를 제외하면 완전히 똑같은 문장이 반복되고 있습니다.
특별한 규칙이 반복된다면 `for`또는 `while` 반복문도 고려해볼만 하지만,
그렇지 않다면 똑같은 문장을 반복해서 써 주는 수 밖에 없겠죠?
C++를 비롯한 대부분의 프로그래밍 언어는, 이렇게 반복되는 문장이 사용되는 것을 피하기 위해 (다른 이유도 많지만), **함수**를 사용합니다.
함수는 다음과 같이 이해하면 편합니다.

```
      +---------------+
      |  3, 'c', 4.0, | arguments
      +---------------+
                   | 
                   V
                 \   /
    +------------+   +-------------------+ 
    |                                    | 
    | double foo(int x, char y, float f) | function
    |                                    |
    +--------------------+   +-----------+
                         /    \
                           |
                           V
                        +--------+
                        | 1234.0 | return value
                        +--------+
```

함수는 일종의 상자입니다.
그 상자는 어떤 타입의 인자를 넘겨줘야 하는 지,
그리고 인자를 넘겨 받으면 어떤 타입의 결과를 돌려주는 지가 정해져 있습니다.
상자에 이름이 있는 경우, 그 이름을 통해 인자를 넘겨주면 결과값을 내 놓는 것이죠 (예시: `foo(3, 'c', 4.0)`).
이름이 없는 값이 있듯이 이름이 없는 함수도 있지만, 일단은 이름이 있는 함수에 대해서만 생각하도록 합니다.
함수를 사용하는 순서는 대게 다음과 같습니다.

1. 함수가 받을 인자와 반환할 값의 타입을 포함해 함수를 선언합니다.
2. 선언된 함수의 인자 타입과 일치하는 인자를 사용해서 함수를 호출합니다.
3. 함수 호출의 결과로 반환되는 값을 사용합니다 (새로운 변수에 덮어쓰기 또는 연산에 사용하기).

이어서 더 자세히 함수를 선언하고 호출하는 방법에 대해 알아보겠습니다.

* **함수의 선언**

보통의 C++ 함수는 파일의 범위에서 선언을 합니다.
(`userspace` 범위 내에서도 선언이 가능하지만 일단은 생각하지 않도록 합시다.)
여기서 보통의 함수란, 이름을 가지고 있고, 파일 내부에서 자유롭게 호출이 가능한 함수를 의미합니다.
파일의 범위란, 어느 함수의 범위에도 속하지 않는 영역을 의미합니다.
함수의 범위는 실제 프로그램을 보면 쉽게 이해할 수 있습니다.
예컨대 앞서 우리가 실행한 C++ 프로그램은 다음과 같은 구조를 가지고 있었죠.

```cpp
#include <iostream>
#include <string>

/************************************/
/*    Define your function here!    */
/************************************/

int main()
{
    // Do something...

    /***************************************************/
    /* You are not allowed to declare a function here! */
    /***************************************************/
}

/************************************/
/*    Define your function here!    */
/************************************/
```

지금까지는 `main()`의 정체에 대해서 말씀을 안 드렸지만, `main()`도 함수입니다.
잠시 후에 살펴볼 함수를 정의하는 문법과 똑같이 생긴 구조입니다.
다만 C++ 프로그램을 실행할 때, 여기서부터 실행하면 된다고 알려주는 특별한 역할을 할 뿐입니다.
어떤 함수의 정의를 나타내기 위해 `{}`로 구분된 블록을 함수의 영역 (scope)이라고 할 수 있습니다.
즉, 새로운 함수를 정의할 때에는, `main()`을 비롯한 다른 함수의 영역 밖에서 선언을 해야 한다는 것입니다.

함수를 정의하는 법은 다음과 같습니다.

> <함수가 반환할 타입> <함수 이름>((<parameter 타입> <parameter 이름>)\*) { 문장; (반환 문장;) }

다소 복잡하지만 코드로 살펴보면 훨씬 직관적입니다.

```cpp
float sum(float x, float y)
{
    float z = x + y;
    return z;
}
```

맨 처음 등장하는 `float`는, 이 함수를 실행하게 되면, 그 결과로서 반환될 값의 타입이 `float`라는 것을 의미합니다.
조금 전에 함수는 상자와 같다고 한 것 기억하시죠?
그리고 그 다음 이어지는 `sum`은 함수의 이름입니다.
함수를 상자에 빗댈 수 있다면, 상자를 불러오는 과정에서 어떤 상자를 부를 지 결정하기 위해 이름이 필요하겠죠?
`()` 내부에는 parameter 목록이 옵니다.
이 때 parameter는 앞서 배운 변수와 비슷하다고 볼 수 있습니다.
변수처럼 이름이 있고, 어떤 값을 가질 수 있죠.
그런데 특이하게도 (1) 함수의 scope 내에서만 유효하고, (2) 값은 함수를 호출하는 순간에 정해집니다.
함수를 호출하는 순간이라는 게 무엇을 의미하는 지는 조금 뒤에 살펴보도록 합시다.
변수와 비슷하게, 함수의 scope 내에서 값을 덮어쓰고, 읽어오는 것 등이 가능합니다.
다만, 값을 덮어쓸 경우에는 덮어쓴 값이 함수 바깥에 영향을 줄 수가 있고 주지 않을 수가 있는데,
이에 대해서는call-by-value냐, 아니면 call-by-referenc냐에 따라서 결정됩니다.
함수를 정의하는 과정에 대해 마저 살펴보도록 합시다.
paremeter 목록 다음에는 `{}`와 그 내부에 함수가 실행할 문장이 따라옵니다.
우리가 앞서 배운 변수 선언, `if` 조건문, `for` 반복문, `while` 반복문 등을 자유롭게 사용할 수 있습니다.
많은 경우에 함수의 마지막 문장은 `return` 반환문이 됩니다.
마지막으로 상자에서 결과물로 돌려줄 값을 계산하고, `return` 다음에 써주면, 함수는 그 값을 돌려줍니다.
이 때 `if` 조건문에서 특정 조건을 만족할 경우 함수의 실행을 빨리 마치고 싶다면 `return`을 일찍 써줘도 됩니다.
다음 함수가 하는 역할을 예상해봅시다.

```cpp
bool is_prime(int n)
{
    if (n == 1)
        return false;

    if (n == 2)
        return true;

    for (int i = 2; i < n / 2; i++) {
        if (n %  i == 0)
            return false;
    }

    return true;
}
```

어떤 함수는 따로 값을 반환하지 않는 경우도 있습니다.
이런 함수의 반환 타입은 `void`라고 합니다.
반환할 값이 없으니 `return` 뒤에 아무 것도 오지 않습니다.
아니면 `return`이 없어도 블록 맨 마지막에 오는 문장을 실행하면 자동으로 실행을 마칩니다.

```cpp
void greetings_to_children(std::string name, int age)
{
    if (age > 13)
        return;

    std::cout << "Hello, " << name << "!\n";
}
```

`src/day3/fun.cpp` 파일을 열고 다양한 함수를 선언해 보도록 합시다.
(예시: 약수의 개수를 구하는 함수, 소문자를 대문자로 바꾸는 함수)

이제는 `main()`이 함수라는 것을 아시겠죠?
그런데 `main()`의 정의를 살펴보면, `int` 타입을 반환해야 하는데 우리는 여태껏 `return` 을 종종 빼먹었습니다.
어째서 별 문제 없이 프로그램이 동작했던 걸까요?
간단히 말씀드리면 `main()`을 정의할 때 반환문을 명시해 주지 않으면, C++가 알아서 `return 0;`이 생략된 것이라고 판단합니다.
여태껏 우리가 작성한 `main()`은 알고보면 0을 반환하고 있었던 것이죠.
참고로 `main()`이 0이 아닌 다른 값을 반환한다는 것은 프로그램을 실행하다가 뭔가가 잘못 됐다는 것을 의미합니다.
문제가 발생했을 경우 `main()` 함수 내부에 `return 1;`을 추가해서 프로그램이 빨리 종료되도록 할 수 있습니다.

```cpp
#include <iostream>

int main()
{
    int x;

    std::cin >> x;

    if (x < 0)
        return 1; // Terminate the program!

    // Do something..
}
```

* **함수의 호출**

* **Call-by-value와 call-by-reference**

TODO

## 3. Recursion

TODO


## 4. More types!
지난 시간에 배운 기초적인 타입으로는 여러 자료를 효과적으로 나타내기 어렵습니다.
예컨대, (1) 같은 타입의 자료를 여러개 모아서 하나의 변수에 저장해주고 싶거나,
(2) 서로 다른 종류의 타입 여러개를 하나로 묶어서 나타내고 싶을 때,
우리가 지난 시간에 배운 타입만으로는 부족하다는 것을 느끼게 됩니다.
만약 지난 시간에 배운 타입만으로 여러 정수의 묶음을 표현하고 싶다면 아래와 비슷한 방법이 최선입니다.

```cpp
int x1, x2, x3, ... ;

std::cin >> x1 >> x2 >> x3 >> ... ;

std::cout << x1 << x2 << x3 << ... ;
```

지난 시간에 배운 반복문을 활용하는 것도 어렵습니다.
한 10개 정도만 있다면 그마나 프로그램을 작성하는 것은 가능하겠지만,
변수가 1,000개 또는 10,000개가 된다면 프로그램을 작성하는 것이 정말 어려워질 것입니다.
다행히도 C++ 에는 이런 경우에 사용하기 좋은 타입이 존재합니다.
이번 시간에는 주로  배열 (Array)과 구초체 (Struct)에 대해 배워보도록 합니다.

* **Array**

Array를 통해 같은 타입의 변수를 한 데 묶어서 저장하고 접근하는 것이 가능합니다.
(참고. `std::vector`, `std::set`, `std::map` 같은 더 복잡한
[자료구조](https://en.wikipedia.org/wiki/Data_structure)를 사용할 수도 있습니다.
물론 직접 만들어서 사용할 수도 있습니다.)
Array는 다음과 같이 선언합니다.

> <타입> <변수명>\[(크기)\] (= {초기 값});

초기값이 주어지는 경우에는 크기를 적어주지 않아도 되지만,
초기값이 주어지지 않는 경우에는 크기를 정해주도록 합니다.
(프로그램을 작성하는 순간에 크기가 정해져야 한다는 게 제약 조건으로 느껴질 수 있습니다.
프로그램이 실행되는 동안 크기가 정해지도록 메모리를 할당하는 방법과 (동적할당),
`std::vector`를 통해서 프로그램이 실행되는 도중에도 크기가 변하는 자료구조에 대해서는 다음에 배워보도록 합니다.)
코드로 보면 다음과 같습니다.

```cpp
int x[3] = { 0, 1, 2 };
char c[] = "Hello, World!\n"; // Though not recommended in C++. Use std::string instead.
double d[4] = { 0.0, 1.0, 2.0 };
std::string greetings[] = { "Hello", "How are you", "Good morning" };
```

이렇게 Array를 선언한 다음에는, `[]` 연산자를 통해 배열의 각 원소에 접근할 수 있습니다.
각 원소에 대해 덮어쓰기 또는 읽어오기가 모두 가능합니다.

```cpp
x[1] = 3;     // updating the value in the array
y = x[2] + z; // loading the value in the array
```

예를 들어 다음 코드는 10개의 정수를 사용자로부터 입력 받아서 홀수에 해당하는 자리에는 'x',
짝수에 해당하는 자리에는 'o'를 출력하는 역할을 합니다.

```cpp
int n[10];
char c[10];

for (int i = 0; i < 10; i++) {
    std::cin >> n[i];
}

for (int i = 0; i < 10; i++) {
    if (n[i] % 2 != 0)
        c[i] = 'x'; // odd numbers
    else 
        c[i] = 'o'
}

for (int i = 0; i < 10; i++) {
    std::cout << c[i];
}
```

위 코드는 별로 좋은 코드는 아닙니다. 어떻게 더 좋게 만들 수 있을까요?
(Hint: 가독성을 해치지 않는 한도 내에서, 반복문 또는 조건문의 사용을 최소화해봅시다.
그리고 `char[]`보다는 `std::string`을 사용하도록 합니다.)

* **Structure**

TODO

* **(Optional) Union**

TODO

* **(Optional) Enum**

TODO

## 5. 과제

TODO
