SPLIT 코딩 학습과정 DAY 2
===

#### Last edit: 4/10/2018
#### Contact: Seonghyun Park <<split.tutor@gmail.com>>

## 1. 학습목표
`main()` 으로부터 실행이 시작되는 C++ 프로그램의 구조에 대해 이해할 수 있다.

`int`, `float`, `char`, `bool`, `std::string` 등 기초적인 타입에 대해 이해한다.

타입과 연산에 대해 생각할 수 있다.

변수를 선언하고 사용할 수 있다.

`if` .. `else`, `while`, `for` 등 control flow에 대해 이해한다.

프로그램 상태를 바탕으로 실행결과가 달라지는 프로그램을 작성할 수 있다.

## 2. C++ 프로그램 구조
실행할 수 있는 C++ 프로그램은 `main()` 이라는 특별한 이름을 가진 함수가 존재합니다. (함수에 대해서는 다음 시간에 배워보도록 합니다.)
지난 시간에 작성했던 예제 프로그램을 생각해봅니다.

```cpp
#include <iostream>
#include <string>

int main()
{
    int year = 0;

    std::string name = "Your name";

    std::cout << "Hello, my name is " << name
              << " and I started programming in " << year << "\n";

    return 0;
}
```

`main()`이라고 이름 붙은 블록  내에 `;`으로 구분되는 문장이 나열된 것을 확인할 수 있습니다.
C++ 프로그램은 우리가 작성한 코드 내에서 `main()`이라고 이름 붙은 이 블록을 찾아서, 우리가 작성한 문장을 순서대로 실행합니다.
이 때 각 문장을 statement라고 부릅니다. 각 statement는 프로그램의 상태를 변화시키는 역할을 합니다.
예컨대 세 번째 statement인 `std::cout << ...`은 프로그램 상태를 변화시켜 화면에 문자열을 출력시키는 역할을 합니다.
이제 각 문장의 의미를 파악해보도록 합시다.

## 3. 타입
현대 컴퓨터에 저장되는 정보는 0과 1의 나열이라고 생각할 수 있습니다.

> 0110110101011101110000110110111011...

0과 1만으로 어떻게 자연수나 실수, 문자열 같은 다양한 형태의 자료를 표현할 수 있는 걸까요?
또 어떤 자료형이 크기가 얼마인 지, 그 경계가 어디인 지 어떻게 구분할 수 있을까요?
C++ 프로그램이 0과 1의 나열을 어떻게 해석할 지에 대해 우리가 직접 힌트를 남겨줘야 합니다.
그 전에 간단한 배경 지식을 짚고 넘어가도록 하겠습니다.

* **정보의 단위**
현대 컴퓨터의 근본이 되는 기술은 0 또는 1의 상태를 나타낼 수 있는 일종의 스위치입니다.
스위치가 켜져 있을 때를 1, 꺼져 있을 때를 0이라고 생각하면, 스위치 하나는 2개의 정보를 저장할 수 있는 셈입니다.
0 또는 1의 정보를 저장할 수 있는 이 정보량을 1-bit라고 표현합니다.
그리고 8-bit가 모이면, 00000000부터 11111111까지 총 256개의 상태를 표현할 수 있는데, 이 정보량을 1 Byte라고 합니다.
더 큰 정보량을 표현하는 단위도 존재합니다.
더 큰 단위를 알아보기 전에 기억해두면 좋은 숫자가 있는데, 2^10은1024이고 이는 약1000에 가까운 숫자입니다.
1024 Byte는 1 Kilobyte (KB) 입니다.
1024 KB는 1 Megabyte (MB) 입니다.
1024 MB는 1 Gigabyte (GB) 입니다.
1024 GB는 1 Terabyte (TB) 입니다.
이제 본격적으로 기본적인 타입에 대해서 알아보도록 합니다.

* **`int` 타입**
가장 처음 보게될 타입은 `int` 타입입니다. 정수를 나타내는 타입이라고 생각할 수 있습니다.
`int` 타입의 크기는 4 Byte입니다. 총 2^32 의 서로 다른 정수를 나타낼 수 있는 정보량입니다.
-2^31 부터 2^32 - 1 까지의 수를 나타낼 수 있습니다.
`int` 타입과 비슷한 타입이 몇 개 있습니다. 대표적으로는 `long`, `unsigned` 등이 있습니다.
`long`은 8 byte로훨씬 많은 정수를 표현할 수 있고, `unsigned`는 0과 자연수만을 표현하는 타입입니다.

* **`float` 타입**
`int`와 같은 4 Byte로 소수를 나타낼 수도 있습니다. 바로 `float` 타입입니다.
크기가 한정되어 있기 때문에,  모든 소수를 표현하는 것은 어렵습니다.
서로 다른 프로그래밍 언어가 소수를 다른 방식으로 표현한다면,
다른 언어로 작성된 프로그램과 의사소통을 하는 데 어려움이 따르게 됩니다.
이런 혼란을 방지하기 위해, 컴퓨터로 소수를 표현하는 규격이 정해져 있습니다 ([IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)).
요약하자면 4 Byte = 32-bit 중 일부는 유효숫자, 일부는 지수로 사용하겠다는 것입니다.
C++ 또한 위 규격을 따릅니다.
`int`와 `long`의 경우와 비슷하게, `float`의 64-bit 버전`double` 타입도 있습니다.

* **`char` 타입**
숫자 뿐만 아니라 문자 또한 C++ 프로그램으로 작성하고 싶습니다.
현재는 유니코드 등 한 문자 당 4 Byte를 사용하는 방식도 있습니다.
하지만 이전에는 문자 하나 당 1 Byte면 충분했기 때문에 문자를 나타내는 타입인 char의 크기는 1 Byte로 정해졌습니다.
내부적으로 `int`와 비슷하게 표현되지만, 컴퓨터는 97이면 `'a'`, 98이면 `'b'` 이런 식으로 이해합니다.

* **`bool` 타입**
`main()`함수를 소개하면서, `main()` 블록은 `;`로 구분된 statement의 모음이고,
C++ 프로그램은 이 문장들을 순서대로 실행하는 것으로 동작한다고 말씀드렸습니다.
하지만 모든 프로그램이 단순히 이 문장들을 순서대로 실행하는 것만 가능하다면,
우리가 만들 수 있는 프로그램의 종류는 크게 제한됩니다.
때로는 프로그램의 흐름에 변화를 주어 프로그램의 동작을 풍부하게 하고 싶습니다.
예컨대, 특정 문장은 조건이 맞아 떨어질 때에만 실행을 하게 한다던지,
특정 문장의 묶음은 원하는 만큼 반복해서 실행하고 싶습니다.
약간의 차이가 있지만, 두 동작 모두 결국 어떠한 조건이 '참'이면 특정 블록을 실행하고
'거짓'이면 그 블록을 실행하지 않게 하는 것이 핵심입니다.
이러한 Control flow에 대해서는 잠시 후에 자세히 배워보도록 하겠습니다.
지금은 '참' 또는 '거짓'을 나타내는 타입의 필요성에 대해 생각해 보도록 합니다.
C++ `bool` 타입은 바로 `true` 또는 `false`의 값을 갖는 타입입니다.
두 종류의 정보를 저장하기 위해서는 1-bit의 정보량이면 충분하지만,
`bool` 타입은 1 Byte의 크기를 가집니다.

* **`std::string` 타입**
앞서 `char` 타입이 문자 하나를 표현한다고 소개했습니다.
문자 하나만 가지고는 우리가 흔히 사용하는 단어나 문장을 나타낼 수 없습니다.
`std::string` 타입은 문자의 묶음인 문자열을 나타내는 타입입니다.
C++ 프로그램 내에서는 큰 따옴표(`"`)를 통해 이 문자열을 나타낼 수 있습니다.

## 3. 연산
 타입을 사용하면 컴퓨터가 0과 1로 이루어진 데이터의 의미를 이해하게 할 수 있다는 것을 배웠습니다.
 이제는 데이터를 사용할 차례입니다. C++에는 데이터를 조작할 수 있는 다양한 연산이 있습니다.
 먼저 정수의 연산에 대해 살펴보도록 하겠습니다.
 C++ 프로그램으로 우리가 알고 있는 정수의 사칙연산을 수행할 수 있습니다.

> 3 + 5, 7 - 12, 5 * 8, 10 / 3, 8 % 5

앞의 세 연산은 익숙한 덧셈, 뺄셈, 곱셈이 보입니다. 그런데 `/`와 `%`는 무엇을 의미할까요?
두 정수의 연산은 기본적으로 정수를 결과물로 가지게 됩니다. 
하지만 정수를 정수로 나누었을 때 항상 정수가 되는 것은 아닙니다.
C++ 정수끼리 나눴을 때 결과물을 분수가 아닌 몫과 나머지로 나타냅니다.
`/`는 앞의 수를 뒤의 수로 나눴을 때의 몫,
`%`는 앞의 수를 뒤의 수로 나누었을 때의 나머지를 나타냅니다.
만약 몫과 나머지가 아닌 실제 분수 값이 알고 싶을 때는 `2.0 / 3` 과 같은 식으로 나타냅니다.
숫자 뒤에 `.0`을 붙임으로써, 실수의 나눗셈을 하고 싶다고 컴퓨터에게 알려주는 것입니다.

비슷하게 `float` 타입에 대해서도 사칙연산을 적용할 수 있습니다.
> 3.0 + 2.0, 7.0 - 12.0, 1.6 * 6.40, 8.0 / 2.1

`std::string`에 대해서도 연산이 정의돼 있습니다. 예컨대 두 `std::string`을 더한다던지 하는 것입니다.
> "I love " + "C++"

하지만 `std::string` 간의 뺄셈, 곱셈, 나눗셈 등을 정의하는 것은 어색합니다.
타입에 따라서 지원할 수 있는 연산이 제한되는 것입니다.

마지막으로 `bool`과 관련된 연산을 살펴보겠습니다.
앞서 살펴본 정수 사이의 연산이 기본적으로 정수의 결과물을 가지고,
실수 사이의 연산이 기본적으로 실수의 결과물을 가지는 것과 달리,
피연산자의 타입과 관계 없이 `bool`을 결과물로 갖는 연산도 존재합니다.
결과가 참 또는 거짓으로 결정되는 연산들입니다.

> 3 == 4 (false), 4 != 7 (true), 3 < 10 (true), 4 >= 11(false)
>
> 3.0 == 3.0 (true), 4.0 <= 10.7 (true)
>
> 'a' < 'b' (true)
>
> "hello" != "world" (true)
>
> true == true (true)

공통적으로 비교와 관련된 연산입니다.
`==`는 두 피 연산자가 같다면 `true`, 다르다면 `false`이고
`!=`는 `==`와 반대의 의미를 가집니다.
`x < y`는 x가 y보다 더 작을 때 `true`, `x <= y`는 x가 y보다 작거나 같으면 `true`입니다.

`bool` 타입 사이에는 특별한 연산이 존재합니다.
바로 `&&`, `||` 그리고 `!` 입니다.
앞의 두 연산자는 `+` 또는 `*` 처럼 두 피 연산자를 필요로 합니다.
`&&`은 '그리고', `||`은 '또는'의 의미를 갖는다고 생각할 수 있습니다.
`x && y`는 `x`와 `y`가 모두 참일 때만 참이고 나머지는 모두 거짓입니다.
`x || y`는 `x`나 `y` 중 하나라도 참이면 참이고 둘 다 거짓일 때에만 거짓입니다.
표로 나타내면 다음과 같습니다

|x    |y    |x &&  y|
|-----|-----|-------|
|true |true |true   |
|true |false|false  |
|false|true |false  |
|false|false|false  |

|x    |y    |x \|\| y |
|-----|-----|---------|
|true |true |true     |
|true |false|true     |
|false|true |true     |
|false|false|false    |

`!` 연산자는 앞의 두 연산자와 달리 하나의 `bool` 타입 피연산자를 가집니다.
이 연산자는 피 연산자가 무엇이든 간에 그 반대 값을 결과로 가집니다.

|x    |!x   |
|-----|-----|
|true |false|
|false|true |

이해를 확인하는 차원에서 다음 연산의 결과를 생각해봅시다

```cpp
3 + 4 * (1.0 / 2.0) + 2 * 8 // ???
('a' < 'c') && ((3 < 8) || 17.0 + 8.1 > 9.00) // ???
```

괄호를 통해 연산의 계산 순서를 바꿔줄 수 있다는 점을 활용하면 좋습니다.

지금까지 몇 종류의 기본적인 타입과 연산에 대해 알아보았습니다.
타입은, 0과 1의 나열에 불과했던 데이터가 의미를 갖게 해주는 역할을 한다고 이해할 수 있습니다.
정수, 소수, 문자, 참/거짓, 문자열 등을 나타내는 타입이 있었습니다.
이런 타입 간의 연산에 대해서도 알아보았습니다.
하지만 아쉽게도, 아직 프로그램을 작성할 수 있는 준비가 되지 않았습니다.
프로그램을 편하게 작성하기 위해서는, 이렇게 타입을 갖춘 데이터에 적절한 이름을 붙여 주어야 합니다.
다음은 데이터에 이름을 붙여 주는 변수 (Variables)에 대해 배워보겠습니다.

## 4. 변수
다시 지난 수업 때 실행했던 첫 프로그램으로 돌아와서, 다음 두 줄을 유심히 살펴봅시다.
```cpp
int year = 0;
std::string name = "Your name";
```

두 문장 모두 다음의 공통된 구조를 가지고 있습니다.

> <타입> <변수명>(= <값>);

이 구조가 바로 변수를 선언하는 문장의 구조입니다. 앞서 살펴본 대로, 변수란 어떤 데이터에 이름을 붙여주는 것이라고 이해할 수 있습니다.
데이터의 초기값을 정해줄 수도 있고, 초기값을 정해주지 않을 수도 있습니다.
주의할 점은, 데이터의 초기값을 정해주지 않고 사용하려고 하면 프로그램이 비정상적으로 동작할 수 있다는 것입니다. 다음은 변수를 선언의 예시입니다.

```cpp
// Declare an int variable without initial value
int x;

// Declare integer values with initial values
int y = 3, z = 5 + 3;

// Declare a character variable with an initial value
char c = 'c';

// Declare a boolean variable with an initial value
bool isTrue = true || false;
```

변수를 선언하는 이유는, 어떤 값과 변수명 사이에 연결고리를 만들어주기 위함입니다.
한 번 변수를 선언해 주면, 변수가 유효한 범위 내에서 변수의 이름만 사용하는 것으로 변수를 사용할 수 있습니다.
이 때 변수가 유효한 범위를 scope라고 하며, 대게 한 블록 안에서 선언된 변수는 그 안에서 유효합니다.
만약 같은 이름의 변수가 바깥 scope에 정의 돼 있더라도, 현재 scope에서 새로운 같은 이름을 가지는 변수를 선언할 수 있습니다.
이 때 선언한 변수는 현재 scope 내에서 선언한 값입니다.
변수를 사용하는 방법에는 크게 두 가지가 있습니다.

1. 변수 덮어쓰기
2. 변수 읽어오기

먼저 변수 덮어 쓰기란 어떤 변수에 기존에 연결돼 있던 값을 잊어버리고 새로운 값을 연결시켜주는 것을 의미합니다.
예컨대 `int x = 5`로 `x`에 값을 저장한 후, 이후 프로그램의 뒷부분에 `x = 3`과 같이 x에 새로운 값을 덮어 쓸 수 있습니다.
변수 읽어오기란, 연산에 필요한 값 대신 변수의 이름을 사용하는 것을 의미합니다.
`int x`, `int y`가 scope 내에 선언되어 있다면, `x + y`와 같이 쓸 수 있습니다.
다만, 사용하려는 연산과 변수의 타입이 서로 잘 맞아 떨어지는 지를 확인할 필요가 있습니다.
`int` 타입 변수 두 개를 피연산자로 하는 `&&`을 계산하려고 한다던지 하는 실수를 하지 않도록 합니다.
변수를 사용하는 프로그램의 예시입니다.
변수 덮어쓰기와 변수 읽어오기가 어떻게 사용됐는 지 확인해볼 수 있습니다.

```cpp
{
    int x = 8;

    {
        ...
        int x = 5;                     -
        ...                            |
        int y = x + 3; // y == 8       | x == 5
        ...                            |
        x = 3;                         -
        ...                            |
        int z = 3 * x // z == 9        | x == 3
        ...                            |
    }                                  -

    int w = x + 9; // w == 17
    z = 9; // ERROR!
```


## 5. Control flow
앞서, 조건에 따라서 특정 문장의 실행 여부를 결정하거나,
특정 문방을 반복해서 실행할 수 있는 기능을 통해 프로그램의 동작을 풍부하게 할 수 있다고 했습니다.
오늘의 마지막 주제로 그런 동작을 하게 하는 프로그램을 어떻게 작성하는 지에 대해 공부해보도록 합니다.
세 가지 문법을 기억하도록 합니다.

* `if`와 `else` 구문
* `while` 반복문
* `for` 반복문

* **`if`와 `else` 구문**
먼저 문장의 구조를 확인하도록 하겠습니다.
> if (조건) 문장
>
> if (조건) 문장 else 문장
>
> if (조건) 문장 else if (조건) 문장 (... else 문장)
>

기본적인 원리는 다음과 같습니다. 먼저 조건에 해당하는 값을 계산합니다.
반드시 `bool` 타입이 와야 하는 것은 아닙니다. 하지만 될 수 있으면 `bool` 타입이 오도록 합니다.
조건이 참일 경우 바로 다음 문장을 실행합니다.
문장은 하나일 수도 있고, 중괄호로 묶인 문장의 모음일 수도 있습니다.
문장은 변수의 선언, 변수 덮어쓰기, 변수 읽어오기, 연산 등을 사용해 구성할 수 있습니다.
조건이 거짓일 경우 참에 해당하는 문장은 실행하지 않습니다.
`else`가 있을 경우에는 조금 더 복잡합니다. 조건을 먼저 계산하는 데에는 변함이 없습니다.
다만 조건이 참일 경우 참에 딸린 문장을 계산하되, 문장이 거짓일 경우 `else`에 해당하는 문장을 실행합니다.
마지막으로 `else`뒤에 새로운 조건이 붙는 경우가 있습니다.
조건이 참일 경우 바로 앞 문장을 실행하고, 조건이 거짓일 경우 다음 조건문으로 넘어가는 것입니다.
계속 반복할 수 있습니다. 다음 프로그램을 실행하면 어떤 결과를 출력할까요?

```cpp
#include <iostream>

/* std::cout << prints the value next to <<. */
int main()
{
    int income = 30000;
    float rate = 0.0;
    int tax;

    if (income < 3000) {
        rate = 0.0;
        std::cout << "Your income level is low. You don't have to pay taxes.\n";
    } else if (income < 7000) {
        rate = 0.03;
        std::cout << "Your income level is so-so.\n";
    } else if (income < 20000) {
        rate = 0.12;
        std::cout << "Your income level is high.\n";
    } else {
        rate = 0.30;
        std::cout << "You are super rich!\n";
    }

    if (rate > 0.0) {
        tax = income * rate;
        std::cout << "You have to pay " << rate << "\n";
    }

    // If the program terminates normally, put `return 0`.
    return 0;
}
```

이 프로그램을 실행하면 다음의 결과를 얻습니다.
> You are super rich!
>
> You have to pay 9000

* **`while` 반복문**
이번에는 특정 문장을 반복해서 실행하는 법에 대해서 배워보도록 합니다.
먼저 문장의 구조는 다음과 같습니다.

> while (조건) 문장

이 문장의 의미는 다음과 같습니다. 먼저 조건을 확인한 후,
조건이 참이면 다음 문장 (블록)을 실행합니다.
블록을 모두 실행한 뒤에는 다시 조건으로 돌아가서 조건이 참인지를 확인힙니다.
이 때 조건이 참이면 블록을 다시 실행하고, 다시 조건을 확인하고.. 조건이 거짓이면 블록을 빠져나와 다음 문장을 실행합니다.
다음 프로그램을 실행하면 어떤 결과를 출력할까요?

```cpp
#include <istream>

/* std::cout << prints the value next to <<. */

int main()
{
    int x = 0; // Initialize x with 0

    while (x < 10) {
	x = 2 * x + 1 // What doese this line do?
	if (x > 5) {
            std::cout << x << " ";
	}
    }

    std::cout << x << "\n"; // `'\n'` means a new line.
}
```
위 프로그램에는 자기 자신의 값을 덮어쓰기 위해 이전 값을 읽어오는 코드가 포함돼 있습니다.
어떻게 동작하는 것인 지고민해보도록 합시다.
이 프로그램을 출력하면 결과는 다음과 같습니다.
프로그램이 실행됨에 따라 x의 값이 어떻게 변하는 지, 그리고 어떤 경로를 따라서 실행되는 지를 잘 살펴보도록 합니다.

```
7 15
```

* **`for` 반복문**
`while` 반복문을 사용해서 특정 문장 또는 블록을 반복해서 실행하는 법을 살펴보았습니다.
하지만 `while` 반복문만으로는 표현하기 어려운 상황이 있습니다.
특정 문장을 반복하되, 정해진 횟수만큼만 실행하는 것입니다.
`while` 반복문만을 사용해서 `hi`를 10번 출력하는 프로그램을 장성하면 다음과 같습니다.

```cpp
#include <iostream>

int main()
{
    int i = 0;

    while (i < 0) {
        std::cout << "hi"
	i = i + 1; // i = i + 1 can also be written as i += 1 or i++ or ++i
    } // hihihihihihihihihihi
}
```
블록 밖에서 변수 `i`를 선언하고, 블록을 실행할 때 마다 변수의 값을 덮어쓰는 식으로 반복의 횟수를 조절할 수 있습니다.
하지만 이런 식으로 반복문을 사용하게 될 경우 몇 가지 문제가 있습니다.
먼저 코드가 의미하는 바를 파악하기 좋지 않습니다.
이 예시는 간단해서 큰 문제는 없지만, 블록의 길이가 길어지고 복잡해지면 문제가 됩니다.
그리고 반복만을 위해서 사용하는 변수 `i`가 블록 밖에서 선언되고 사용되는 것도 좋지 않습니다.
다른 값을 덮어 씌움으로써 변수의 이름을 재사용할 수는 있지만 바람직한 방법은 아닙니다.
C++ 프로그램에서 정해진 횟수만큼 문장을 실행하는 것은 자주 등장하는 동작이기 때문에,
그를 표현하기 위한 `for` 반복문 문장 구조가 따로 존재합니다.
문장의 구조는 다소 복잡합니다.

> for (초기화; 조건; 업데이트) 문장

문법은 다소 복잡하지만 이 문장이 하는 일은 다음과 같습니다.

1. 먼저 초기화에 대항하는 문장을 실행합니다.
2. 조건이 참인지를 확인합니다.
3. 조건이 참일 경우 문장을 실행합니다.
4. 문장을 실행한 후 업데이트를 실행합니다.
5. 조건이 참인 지를 확인합니다.
6. 조건이 참일 경우 문장을 실행합니다. (4-6을 반복)

예시를 확인하면 쉽게 이해할 수 있습니다.

```cpp
#include <iostream>

int main()
{
    for (int i = 0; i < 10; i++) {
        std::cout << "hi " << i + 1 << "\n";
    }
}
```

실행 결과는 다음과 같습니다
```
hi 1
hi 2
...
hi 10

```

`for` 및 `while` 반복문은 다중으로 중첩해서 사용하는 것도 가능합니다.
다중으로 중첩해서 사용할 경우, 초기화해서 사용하는 변수의 이름이 같지 않도록 주의합니다.
같을 경우 대게 코드의 동작을 파악하는 게 어렵습니다.

* **`break`, `continue`**
C++의 반복문은 반복문에 딸린 문장을 실행하는 도중에 반복문을 빠져나오거나, 다시 조건으로 돌아가 확인하게 할 수 있습니다. 반복문을 빠져나오고 싶을 때는 `break;`,
반복문의 조건으로 돌아가 다시 검사를 수행하고 싶을 때에는 `continue;`를 사용하면 됩니다.
직접 `break` 및 `continue` 를 사용하는 반복문을 작성해보도록 합니다.

## 6. 마무리 및 과제
상당히 많은 내용을 다뤘습니다.
타입, 연산, 변수, `if-else` 조건문, `while`, `for` 반복문 등 C++ 프로그램을 작성하는 데 필요한 기본적인 요소를 다뤄보았습니다.
지금까지 배운 내용을 바탕으로 과제를 해결해보도록 하겠습니다.

**과제 1: 암호화 및 복호화**
가장 간단한 암호화 기법은 특정 규칙에 따라 문자를 치환하는 것입니다.
예컨대, a 대신에 d, b 대신에 e, ... 처럼 정해진 크기만큼 문자를 shift하는 방법이 있을 수 있고,
정해진 규칙에 따라 임의로 문자를 치환하는 방법도 있습니다.
물론 이 경우에는 암호를 보내는 사람과 다시 복호화해야 하는 사람이 규칙을 공유해야 하지요.
이번에는 간단한 [ROT13](https://en.wikipedia.org/wiki/ROT13) 암호화 및 복호화 알고리즘을 구현해보도록 합니다.
알파벳이 아닌 경우에는 따로 암호화 또는 복호화하지 않도록 합니다.
`char` 타입도 대소 비교가 가능하고, `+` 및 `-`를 통해서 값을 계산할 수 있다는 점을 활용합니다.
예를 들면, `'a' < 'd'`이고, `'a' + 13 = 'n'`입니다.
주어진 [뼈대 코드](https://github.com/split-tutor/cpp-tutorial)의 빈칸을 채워넣어보도록 합니다.
참고로 뼈대 코드에 존재하는 `for (char c : plain)`은 `std::string` 의 각 문자에 대해 다음 문장을 반복하겠다는 의미입니다.
더 자세한 내용은 [range-based for loop](https://en.cppreference.com/w/cpp/language/range-for)에서 찾아볼 수 있습니다.
뼈대 코드를 실행하게 되면 콘솔을 통해 문자열을 입력할 수 있습니다.
뼈대 코드는 암호화 후 복호화를 거쳤을 때, 입력과 동일한 값이 출력되는 지를 확인합니다.

**과제 2: 소수 판별법**

100 이하의 모든 소수를 출력하는 프로그램을 작성해보도록 하겠습니다.
우선 어떤 자연수가 소수라는 것은, 1보다 크고 그 자연수보다 작은 어떤 수로도 나누어지지 않는다는 것을 의미합니다.
정수의 연산에 대해 배울 때, `%` 라는 연산이 있던 것을 기억하시나요?
그리고 1보다 크고 그 자연수보다 작은 모든 수에 대해서 확인해보려면 반복문을 사용해야 할 것 같은 느낌이 듭니다.
그리고 같은 작업을 100 이하의 모든 자연수에 대해서 진행해야 하겠죠?
2중 반복문이 필요할 수 있습니다.
문제가 다소 어려울 수 있지만, 한 번 도전해보기 바랍니다.

감사합니다.
